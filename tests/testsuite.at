AT_INIT
AT_COLOR_TESTS

m4_define([FIND_ZEUGL], [[set -x
if test "$AUTOTEST_PATH" == "$at_testdir"; then
    zeugl="$abs_top_builddir/cli/zeugl"
    compare="$(dirname "$zeugl")/.libs/lt-zeugl"
else
    LD_LIBRARY_PATH="$AUTOTEST_PATH/../lib" export LD_LIBRARY_PATH
    zeugl="$AUTOTEST_PATH/zeugl"
    compare="$(zeugl)"
fi]])


########################################

AT_SETUP([Test suite sanity check])
AT_CHECK(echo -n Hello Zeugl, 0, Hello Zeugl)
AT_CLEANUP

########################################

AT_SETUP([Create file with mode])
FIND_ZEUGL

# Create file with mode 644
AT_CHECK(["$zeugl" -df /dev/null -c 644 testfile.txt], [0], [ignore])

# Check that file has mode 644
AT_CHECK([stat testfile.txt --format %a], [0], [644
])

AT_CLEANUP

########################################

AT_SETUP([Existing file mode is kept])
FIND_ZEUGL

# Create an empty file with mode 644
AT_CHECK([install -m 644 /dev/null testfile.txt])

# Create the file with mode 600 if it does not exist
AT_CHECK(["$zeugl" -df /dev/null -c 600 testfile.txt], [0], [ignore])

# Check that zeugl respected existing file mode
AT_CHECK([stat testfile.txt --format %a], [0], [644
])

AT_CLEANUP

########################################

AT_SETUP([Fail if original file is missing])
FIND_ZEUGL

AT_CHECK(["$zeugl" -df /dev/null testfile.txt], [1], [ignore])

AT_CLEANUP

########################################

AT_SETUP([Fail if input file is missing])
FIND_ZEUGL

AT_CHECK(["$zeugl" -df no-such-file.txt -c 644 testfile.txt], [1], [ignore])

AT_CLEANUP

########################################

AT_SETUP([Expected content from stdin])
FIND_ZEUGL

# Read from stdin
AT_CHECK([echo -n "Hello zeugl" | "$zeugl" -dc 644 testfile.txt], [0], [ignore])

# Check expected content
AT_CHECK([cat testfile.txt], [0], [Hello zeugl])

AT_CLEANUP

########################################

AT_SETUP([Expected content from input file])
FIND_ZEUGL

# Create input file
AT_DATA([input.txt], [Hello zeugl
])

# Use zeugl to copy input data into testfile.txt
AT_CHECK(["$zeugl" -df input.txt -c 644 testfile.txt], [0], [ignore])

# Check that testfile.txt contains input data
AT_CHECK([cat testfile.txt], [0], [Hello zeugl
])

AT_CLEANUP

########################################

AT_SETUP([File is not truncated by default])
FIND_ZEUGL

# Create input file
AT_DATA([input.txt], [bar
foo
])

# Create test file
AT_DATA([testfile.txt], [foo
bar
baz
])

# Copy input file to test file without truncation
AT_CHECK(["$zeugl" -df input.txt testfile.txt], [0], [ignore])

# Check that test file was not truncated
AT_CHECK([cat testfile.txt], [0], [bar
foo
baz
])

AT_CLEANUP

########################################

AT_SETUP([File is truncated when specified])
FIND_ZEUGL

# Create input file
AT_DATA([input.txt], [bar
foo
])

# Create test file
AT_DATA([testfile.txt], [foo
bar
baz
])

# Copy input file to test file without truncation
AT_CHECK(["$zeugl" -dtf input.txt testfile.txt], [0], [ignore])

# Check that test file was not truncated
AT_CHECK([cat testfile.txt], [0], [bar
foo
])

AT_CLEANUP

########################################

AT_SETUP([Create file with mode when truncated])
FIND_ZEUGL

# Create and truncate file with mode 640
AT_CHECK(["$zeugl" -df /dev/null -tc 640 testfile.txt], [0], [ignore])

# Check that file has mode 640
AT_CHECK([stat testfile.txt --format %a], [0], [640
])

AT_CLEANUP

########################################

AT_SETUP([Existing file mode is kept when truncated])
FIND_ZEUGL

# Create an empty file with mode 644
AT_CHECK([install -m 644 /dev/null testfile.txt])

# Create the file with mode 600 if it does not exist
AT_CHECK(["$zeugl" -df /dev/null -tc 600 testfile.txt], [0], [ignore])

# Check that zeugl respected existing file mode
AT_CHECK([stat testfile.txt --format %a], [0], [644
])

AT_CLEANUP

########################################

AT_SETUP([File is appended when specified])
FIND_ZEUGL

# Create test file
AT_DATA([testfile.txt], [foo
])

# Create input file
AT_DATA([input.txt], [bar
])

# Append input file to test file
AT_CHECK(["$zeugl" -daf input.txt testfile.txt], [0], [ignore])

# Check that test file was appended
AT_CHECK([cat testfile.txt], [0], [foo
bar
])

AT_CLEANUP

########################################

AT_SETUP([Test multithreaded file manipulation])

# Skip if note compiled with pthreads
AT_SKIP_IF([! grep -qE "^#define HAVE_PTHREAD 1$" "$abs_top_builddir/config.h"])

# Run multithreaded test
AT_CHECK(["$abs_top_builddir/tests/test_multithreaded" 128 $((20 * 1024 * 1024)) testfile], [0], [ignore])

AT_CLEANUP

########################################

AT_SETUP([Test multiprocess file manipulation])

# Make sure shell script is executable
chmod +x "$abs_top_builddir/tests/test_multiprocess.sh"

# Run multiprocess test
AT_CHECK(["$abs_top_builddir/tests/test_multiprocess.sh" 128 $((20 * 1024 * 1024)) testfile], [0], [ignore])

AT_CLEANUP

########################################

AT_SETUP([Test cleanup on SIGTERM])

"$abs_top_builddir/tests/test_cleanup" signal &
PID=$!
sleep 1

# Check that file exists
AT_CHECK([test -e test_file.txt.??????], [0])

# Wait for child process to finish
wait "$PID"

# Check that file is cleaned up
AT_CHECK([test -e test_file.txt.??????], [1])

# Check that signal handlers are chained
AT_CHECK([test -e hello-from-chained-signal-handler], [0])

AT_CLEANUP

########################################

AT_SETUP([Test no cleanup on abort()])

"$abs_top_builddir/tests/test_cleanup" abort &
PID=$!
sleep 1

# Check that file exists
AT_CHECK([test -e test_file.txt.??????], [0])

# Wait for child process to finish
wait "$PID"

# Check that file is not cleaned up
AT_CHECK([test -e test_file.txt.??????], [0])

AT_CLEANUP

########################################

AT_SETUP([Test cleanup at exit])

"$abs_top_builddir/tests/test_cleanup" &
PID=$!
sleep 1

# Check that file exists
AT_CHECK([test -e test_file.txt.??????], [0])

# Wait for child process to finish
wait "$PID"

# Check that file is cleaned up
AT_CHECK([test -e test_file.txt.??????], [1])

AT_CLEANUP

########################################

AT_SETUP([Check formatting on C code])

# Skip if clang-format is not installed
AT_SKIP_IF([! command -v clang-format])

# Run clang-format on all source files
for file in "$abs_top_builddir"/**/*.{c,h}; do
    AT_CHECK([clang-format --dry-run --Werror "$file"])
done

AT_CLEANUP

########################################

AT_SETUP([Static check C code])

# Skip if cppcheck is not installed
AT_SKIP_IF([! command -v cppcheck])

AT_CHECK([cppcheck --force --error-exitcode=1 --check-level=exhaustive \
--enable=all --disable=missingInclude --include="$abs_top_builddir"/config.h \
-I "$abs_top_builddir"/ -I "$abs_top_builddir"/lib/ "$abs_top_builddir"],
[0], [ignore], [ignore])

AT_CLEANUP

########################################

AT_SETUP([Check formatting on shell scripts])

# Skip if shfmt is not installed
AT_SKIP_IF([! command -v shfmt])

# Run shfmt on all shell files
for file in "$abs_top_builddir"/**/*.sh; do
    AT_CHECK([shfmt --diff "$file"])
done

AT_CLEANUP

########################################

AT_SETUP([Static check shell scripts])

# Skip if shellcheck is not installed
AT_SKIP_IF([! command -v shellcheck])

# Run shellcheck on all shell files
for file in "$abs_top_builddir"/**/*.sh; do
    AT_CHECK([shellcheck "$file"])
done

AT_CLEANUP

########################################
